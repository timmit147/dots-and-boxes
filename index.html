<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dots and Boxes Improved</title>
<style>
  body {
    background: #111;
    color: white;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  svg {
    background: #222;
    border-radius: 10px;
    margin-top: 20px;
    cursor: pointer;
  }
  .dot {
    fill: white;
  }
  .edge {
    stroke-width: 4;
    stroke: rgba(255,255,255,0.06);
    transition: stroke 0.15s;
  }
  .box {
    fill-opacity: 0.3;
  }
  :root {
    --p1: rgb(124, 58, 237);
    --p2: rgb(239, 68, 68);
    --preview-p1: rgba(124, 58, 237, 0.5);
    --preview-p2: rgba(239, 68, 68, 0.5);
  }
</style>
</head>
<body>

<h1>Dots and Boxes</h1>
<div id="score"></div>
<div id="board"></div>

<script>
const Ndots = 5; // grid size
let state = {
  h: {}, // horizontal edges
  v: {}, // vertical edges
  boxes: {},
  turn: 0, // 0 = P1, 1 = P2
  score: [0, 0]
};
let paused = false;
let previewedEdge = null;

function hk(r, c) { return `h_${r}_${c}`; }
function vk(r, c) { return `v_${r}_${c}`; }
function bk(r, c) { return `b_${r}_${c}`; }

function initState() {
  for (let r = 0; r < Ndots; r++) {
    for (let c = 0; c < Ndots-1; c++) {
      state.h[hk(r, c)] = null;
    }
  }
  for (let r = 0; r < Ndots-1; r++) {
    for (let c = 0; c < Ndots; c++) {
      state.v[vk(r, c)] = null;
    }
  }
  for (let r = 0; r < Ndots-1; r++) {
    for (let c = 0; c < Ndots-1; c++) {
      state.boxes[bk(r, c)] = null;
    }
  }
}
initState();

function renderBoard() {
  const spacing = 60;
  const dotR = 6;
  const W = spacing * (Ndots - 1) + 48;
  const H = W;

  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", W);
  svg.setAttribute("height", H);

  // edges (real clickable lines)
  for (let r = 0; r < Ndots; r++) {
    for (let c = 0; c < Ndots-1; c++) {
      const x1 = 24 + c * spacing, y1 = 24 + r * spacing;
      const x2 = x1 + spacing, y2 = y1;
      const edge = document.createElementNS(svgNS, "line");
      edge.setAttribute("x1", x1);
      edge.setAttribute("y1", y1);
      edge.setAttribute("x2", x2);
      edge.setAttribute("y2", y2);
      edge.setAttribute("class", "edge");
      edge.dataset.id = hk(r, c);
      svg.appendChild(edge);
    }
  }
  for (let r = 0; r < Ndots-1; r++) {
    for (let c = 0; c < Ndots; c++) {
      const x1 = 24 + c * spacing, y1 = 24 + r * spacing;
      const x2 = x1, y2 = y1 + spacing;
      const edge = document.createElementNS(svgNS, "line");
      edge.setAttribute("x1", x1);
      edge.setAttribute("y1", y1);
      edge.setAttribute("x2", x2);
      edge.setAttribute("y2", y2);
      edge.setAttribute("class", "edge");
      edge.dataset.id = vk(r, c);
      svg.appendChild(edge);
    }
  }

  // boxes
  for (let r = 0; r < Ndots-1; r++) {
    for (let c = 0; c < Ndots-1; c++) {
      const rect = document.createElementNS(svgNS, "rect");
      rect.setAttribute("x", 24 + c * spacing);
      rect.setAttribute("y", 24 + r * spacing);
      rect.setAttribute("width", spacing);
      rect.setAttribute("height", spacing);
      rect.setAttribute("class", "box");
      rect.dataset.id = bk(r, c);
      rect.setAttribute("fill", "transparent");
      svg.appendChild(rect);
    }
  }

  // dots
  for (let r = 0; r < Ndots; r++) {
    for (let c = 0; c < Ndots; c++) {
      const cx = 24 + c * spacing, cy = 24 + r * spacing;
      const dot = document.createElementNS(svgNS, "circle");
      dot.setAttribute("cx", cx);
      dot.setAttribute("cy", cy);
      dot.setAttribute("r", dotR);
      dot.setAttribute("class", "dot");
      svg.appendChild(dot);
    }
  }

  svg.addEventListener("mousemove", (e) => {
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
    let closest = findClosestEdge(svgP.x, svgP.y);
    if (closest) previewEdge(closest.type, closest.r, closest.c);
    else clearPreview();
  });

  svg.addEventListener("mouseleave", clearPreview);
  svg.addEventListener("click", (e) => {
    if (paused) return;
    const pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
    let closest = findClosestEdge(svgP.x, svgP.y);
    if (closest) claimEdge(closest.type, closest.r, closest.c);
  });

  document.getElementById("board").innerHTML = "";
  document.getElementById("board").appendChild(svg);
  updateBoardGraphics();
}

function findClosestEdge(x, y) {
  const spacing = 60;
  let best = null;
  let bestDist = 20; // tolerance
  for (let r = 0; r < Ndots; r++) {
    for (let c = 0; c < Ndots - 1; c++) {
      const mx = 24 + c * spacing + spacing/2;
      const my = 24 + r * spacing;
      const dist = Math.hypot(x - mx, y - my);
      if (dist < bestDist && state.h[hk(r, c)] === null) {
        bestDist = dist;
        best = { type: 'h', r, c };
      }
    }
  }
  for (let r = 0; r < Ndots - 1; r++) {
    for (let c = 0; c < Ndots; c++) {
      const mx = 24 + c * spacing;
      const my = 24 + r * spacing + spacing/2;
      const dist = Math.hypot(x - mx, y - my);
      if (dist < bestDist && state.v[vk(r, c)] === null) {
        bestDist = dist;
        best = { type: 'v', r, c };
      }
    }
  }
  return best;
}

function previewEdge(type, r, c) {
  clearPreview();
  let id = (type === 'h') ? hk(r, c) : vk(r, c);
  if ((type === 'h' && state.h[id] !== null) || (type === 'v' && state.v[id] !== null)) return;
  const svg = document.querySelector("svg");
  previewedEdge = svg.querySelector(`.edge[data-id="${id}"]`);
  if (previewedEdge) {
    previewedEdge.setAttribute("stroke",
      state.turn === 0
        ? getComputedStyle(document.documentElement).getPropertyValue("--preview-p1")
        : getComputedStyle(document.documentElement).getPropertyValue("--preview-p2")
    );
  }
}

function clearPreview() {
  if (previewedEdge) {
    const id = previewedEdge.dataset.id;
    let owner = null;
    if (id.startsWith("h_")) owner = state.h[id];
    if (id.startsWith("v_")) owner = state.v[id];
    previewedEdge.setAttribute(
      "stroke",
      owner === null
        ? "rgba(255,255,255,0.06)"
        : owner === 0
          ? getComputedStyle(document.documentElement).getPropertyValue("--p1")
          : getComputedStyle(document.documentElement).getPropertyValue("--p2")
    );
    previewedEdge = null;
  }
}

function claimEdge(type, r, c) {
  let id = (type === 'h') ? hk(r, c) : vk(r, c);
  if ((type === 'h' && state.h[id] !== null) || (type === 'v' && state.v[id] !== null)) return;
  if (type === 'h') state.h[id] = state.turn;
  else state.v[id] = state.turn;

  let scored = checkForBoxes(type, r, c);
  if (!scored) state.turn = 1 - state.turn;

  updateBoardGraphics();
}

function checkForBoxes(type, r, c) {
  let scored = false;
  const adj = [];
  if (type === 'h') {
    if (r > 0) adj.push([r-1, c]);
    if (r < Ndots-1) adj.push([r, c]);
  } else {
    if (c > 0) adj.push([r, c-1]);
    if (c < Ndots-1) adj.push([r, c]);
  }
  adj.forEach(([br, bc]) => {
    if (
      state.h[hk(br, bc)] !== null &&
      state.h[hk(br+1, bc)] !== null &&
      state.v[vk(br, bc)] !== null &&
      state.v[vk(br, bc+1)] !== null &&
      state.boxes[bk(br, bc)] === null
    ) {
      state.boxes[bk(br, bc)] = state.turn;
      state.score[state.turn]++;
      scored = true;
    }
  });
  return scored;
}

function updateBoardGraphics() {
  const svg = document.querySelector("svg");
  for (const id in state.h) {
    const edge = svg.querySelector(`.edge[data-id="${id}"]`);
    if (state.h[id] === null) edge.setAttribute("stroke", "rgba(255,255,255,0.06)");
    else edge.setAttribute("stroke", state.h[id] === 0 ? "var(--p1)" : "var(--p2)");
  }
  for (const id in state.v) {
    const edge = svg.querySelector(`.edge[data-id="${id}"]`);
    if (state.v[id] === null) edge.setAttribute("stroke", "rgba(255,255,255,0.06)");
    else edge.setAttribute("stroke", state.v[id] === 0 ? "var(--p1)" : "var(--p2)");
  }
  for (const id in state.boxes) {
    const box = svg.querySelector(`.box[data-id="${id}"]`);
    if (state.boxes[id] === null) box.setAttribute("fill", "transparent");
    else box.setAttribute("fill", state.boxes[id] === 0 ? "var(--p1)" : "var(--p2)");
  }
  document.getElementById("score").innerText = `P1: ${state.score[0]}  P2: ${state.score[1]} â€” Turn: P${state.turn+1}`;
}

renderBoard();
</script>

</body>
</html>
